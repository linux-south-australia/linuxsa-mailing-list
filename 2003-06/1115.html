<HTML>
<!-- EmailData="Start" -->
<!-- Version="1.1" -->
<!-- Subject="RE: Some Proposals for a Linux of The Future (tm) :)" -->
<!-- FromName="'Richard Russell'" -->
<!-- FromEmail="richard@yellowgoanna.com" -->
<!-- ToName="'Damien Uern'," -->
<!-- ToEmail="carrigan_2606@optusnet.com.au,linuxsa@linuxsa.org.au" -->
<!-- Date="Sat, 28 Jun 2003 23:33:27 +0930" -->
<!-- Id="001501c33d7e$243f07b0$020120ac@skink" -->
<!-- Reference="200306281830.14042.carrigan_2606@optusnet.com.au" -->
<!-- X-Face="" -->
<!-- X-URL="" -->
<!-- EmailData="End" -->
<HEAD>
<TITLE>LinuxSA Mailing List: RE: Some Proposals for a Linux of The Future (tm) :)</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF><H1>LinuxSA Mailing list archives</H1>
<!-- IndexControl1="Start" -->
Index:
[<A HREF="thread.html">thread</A>]
[<A HREF="date.html">date</A>]
[<A HREF="subject.html">subject</A>]
[<A HREF="author.html">author</A>]
[<A HREF="stats.html">stats</A>]
<HR>
<!-- IndexControl1="End" -->
<!-- Header="Start" -->
<PRE>
  From: Richard Russell &lt;<I><A HREF="mailto:richard@yellowgoanna.com">richard@yellowgoanna.com</A></I>&gt;
  To  : Damien Uern &lt;<I><A HREF="mailto:carrigan_2606@optusnet.com.au">carrigan_2606@optusnet.com.au</A></I>&gt;<BR>        &lt;<I><A HREF="mailto:linuxsa@linuxsa.org.au">linuxsa@linuxsa.org.au</A></I>&gt;
  Date: Sat, 28 Jun 2003 23:33:27 +0930
</PRE>
<H1>RE: Some Proposals for a Linux of The Future (tm) :)</H1>
<!-- Header="End" -->
<!-- Body="Start" -->
<PRE>
Hi again Damien,

Just thought I'd let you know that I don't have it in for you or anything,
and don't intend to go on contradicting you :) It's just that these two
topics are ones I'm interested in, so your emails prompted me to do some
research... :)

&gt; Thanks for your comments. I have skimmed through the most recent LSB 
&gt; specification (I don't have download access so I can't do any 
&gt; research atm), 
&gt; and it doesn't seem to specify all that much, perhaps I 
&gt; should look at it 
&gt; again. If they are indeed packaging software for an LSB reference 

I don't know that it does specify much, but I think their goal is partially
to be acheivable and useful, rather than perfect but non-existent (they
emphasise the practical over the theoretical)...

&gt; implementation, then this is basically *exactly* what I want. 
&gt; I would love if 
&gt; you could go to the website of a project and download 
&gt; "app-3.2-lsb.i586.rpm" 
&gt; and have it *just work* without farting around with 
&gt; compatibility problems.

This is exactly what I want, and why I first went to Debian, and why I am
now experimenting with FreeBSD. It's also what draws me to gentoo, but there
are other reasons that push me away from there. I have a feeling that what
you want will be found in an individual distribution, rather than a
standards document... Then again, it depends what you want -- are you after
hassle-free upgrades and installation, or a Unified Linux Distribution?

&gt; 
&gt; The problem with rpm is that dependency issues can be a 
&gt; nightmare (especialy 
&gt; for the newbie). Even with urpmi on Mandrake I still have 
&gt; problems from 
&gt; braindead packages. For example, I installed juk from 
&gt; Textstar's repository, 
&gt; however it wanted to download like 130MB of packages. He had 
&gt; made this 
&gt; package depend on *his* KDE packages, even though I had KDE 
&gt; 3.1 installed and 
&gt; met the requirements of the program. I installed with rpm 
&gt; --nodeps, and it 
&gt; worked fine.

I have a feeling that to a large degree, this is not a problem with rpm per
se, but with the management of the repositories. This is Debian's huge
advantage -- they have a strict policy that means that dependencies are
always right, though not neccessarily exactly what you want (being
precompiled and all). FreeBSD's ports system appears to come close, but
loses (by a small amount) to Debian in this regard because it is a dynamic
set of packages/ports, and hence the dependencies change and occasionally
break in minor ways (see my other email, "adventures with ports"). That
said, this appears to be the cost of being up-to-date, which is one place
where FreeBSD wins out over Debian hands-down.

&gt; 
&gt; If there was an LSB package of juk, I wouldn't want it to 
&gt; depend on LSB's 
&gt; version of KDE, I would want it to depend on the version of 
&gt; KDE that I have 
&gt; installed, be it installed from a Mandrake package or from 
&gt; some other source. 
&gt; The root of the problem here is that rpm depends on 
&gt; *packages* rather than 
&gt; files. The dependency resolution should see that I have 
&gt; /usr/lib/libqt-3.1.0 
&gt; and say "well that's what I want", and install without complaining.

FreeBSD's ports appears to do just this (I don't know the intricacies), and
if it doesn't find the file, it knows which port to find it in, and will
install that port. (which is how the problem in my other email came about).

&gt; 
&gt; But what to do if libqt-3.1.0 is missing? It's a 2MB library, 
&gt; do we want the 
&gt; package manager to want to download a 50MB KDE RPM in order 
&gt; to install it? 
&gt; There needs to be more fine-grained dependency resolution. 
&gt; Maybe instead of 
&gt; depending on "kdecore-3.1.2-mdk.i586.rpm", it depends on 
&gt; "kdecore &gt;= 3.1" and 
&gt; whatever package provides that gets installed.

That's similar to how Debian does things...

&gt; 
&gt; All of these issues and more are goals of the "autopackage" project, 
&gt; www.autopackage.org, and so I am hopeful that the future of 
&gt; installing 
&gt; GNU/Linux software will be much brighter.

Interesting. I took a look at that, and it does have some appeal. However, I
fail to see how a decentralised system will actually work. The problem of
dependency checking is one that lends itself to centralisation. The most
decentralised I've seen that works is FreeBSD's ports. 

&gt; 
&gt; --
&gt; 
&gt; Anyway, as for my first idea (new etc layout/config stuff), 
&gt; this is the most 
&gt; important IMO. You bring up some good points about the implementation 
&gt; problems of such a standard, and indeed I was thinking of 
&gt; these problems last 
&gt; night.
&gt; 
&gt; I think it would be extremely difficult, if not impossible to 
&gt; implement a 
&gt; configuration file syntax that meets my stated goals below 
&gt; (i.e. human 
&gt; readable *and* able to define a GUI). I didn't want to have 
&gt; xml configuration 
&gt; files, because I believe they are very difficult to read. For example:

I agree, it's just the buzzword of the week, and I thought I'd take the
opportunity to air it again.

&gt; 
&gt; What is easier to read, this:
&gt; 
&gt;       &lt;defaults&gt;
&gt;         &lt;DefaultMenuLanguage&gt;en&lt;/DefaultMenuLanguage&gt;
&gt;         &lt;DefaultAudioLanguage&gt;en&lt;/DefaultAudioLanguage&gt;
&gt;         &lt;DefaultSubtitleLanguage&gt;en&lt;/DefaultSubtitleLanguage&gt;
&gt;         &lt;ParentalCountry&gt;US&lt;/ParentalCountry&gt;
&gt;         &lt;ParentalLevel&gt;15&lt;/ParentalLevel&gt;
&gt;         &lt;PlayerRegion&gt;1&lt;/PlayerRegion&gt;
&gt;       &lt;/defaults&gt;
&gt; 
&gt; or this?
&gt; 
&gt; [Defaults]
&gt; DefaultMenuLanguage=en
&gt; DefaultAudioLangauge=en
&gt; DefaultSubtitleLanguage=en
&gt; ParentalCountry=US
&gt; ParentalLevel=15
&gt; PlayerRegion=1
&gt; 

The second, but then, it suffers from not being flexible enough. Some config
files require deeper nesting that this -- what about Apache, for eg... There
are directives that can be global, or can be local to a virtualserver, and
so on... you really do need some way of ending the [defaults] section
heading, without neccessarily starting a new one. Personally, I have a
distaste for the [section] style config files, probably because they remind
me of .ini files. However, I don't doubt that there is a single format that
is powerful and flexible enough, as well as being both readable and
parseable...

&gt; I think the only solution would be to, as you suggested, have a GUI 
&gt; description file, and have a tool that generates the config 
&gt; file from that. 
&gt; But what's the problem with this? Changes to the config file 
&gt; are lost and one 
&gt; of my design goals are violated (allowing the user to modify 
&gt; the config file 
&gt; without the GUI app treading all over it) - similar to the 
&gt; Linuxconf tool you 
&gt; mentioned.

This is a major problem, yes. You could also declare the original
(software-specific) config file to be null and void, and actually make
people use the UCF (Universal/Uern Configuration Format) file when editing
files -- if you want to change all the config file formats anyway, and
didn't want to force application writers to rewrite their applications, then
this could be a viable method...

&gt; I was originally thinking that the config file syntax would 
&gt; allow for a lot of 
&gt; interpretation by the GUI program, but I could imagine some 
&gt; rather horrible 
&gt; looking GUI's coming from that. I also wanted the various 

either horrible looking GUIs or terrible config files...

&gt; configuration 
&gt; variables to have types so that the GUI could complain if the 
&gt; user tried to 
&gt; set a variable to an erroneous value (e.g an Integer type 
&gt; being set to a 
&gt; string).

This would be something that you wouldn't really want cluttering the actual
config file, you'd want to put that in the defaults or GUI-definining
file...

&gt; 
&gt; In order to meet design goal of allowing a user to edit the 
&gt; configuration file 
&gt; by hand, prehaps we should borrow some ideas from C++ and OO 
&gt; programming.

ugh. please don't borrow things from C++ to make things easily editable --
the only thing that could be worse would be perl ;) ;) ;)

&gt; 
&gt; What if the layout file describes only the layout and the 
&gt; modifyable variables 
&gt; (i.e. the header file, or class description), and the 
&gt; configuration file 
&gt; contains the values for those variables (the "implementation"). The 
&gt; configuration file should have a syntax such that it can be 
&gt; parsed by a 
&gt; program and modified variables can be updated easily.

Sure... (If it were my metaphor, I would choose to think of the layout file
being the class, and the config file being an instantiation of that class --
ie an object)

&gt; 
&gt; The layout file could also borrow some other OO terms, such 
&gt; as "public" and 
&gt; "private" variables, i.e. ones that are for the programs 
&gt; internal use, and 
&gt; others that are meant to be modifyable by the user. Only 
&gt; public variables 
&gt; would be displayed by the GUI.

Why would you want private variables in a config file in the first place? I
can't think of any instance where a current config file has real
non-user-modifiable information...

&gt; 
&gt; All possible configuration variables accepted by the program 
&gt; should be 
&gt; described in the layout file. A whole class of variables 
&gt; should be able to be 
&gt; made "private" so that the GUI doesn't display them, but are 
&gt; available to the 
&gt; advanced user should he/she want them. This allows the graphical user 

That's sensible...

&gt; interface to be simple and readable without being overloaded 
&gt; with options. It 
&gt; also allows the configuration file to contain data useful for 
&gt; the program 
&gt; internally, but not the user.

I like the idea of differing levels of configuration, but don't understand
the "private" bits.

&gt; 
&gt; Anyway, this will need to be thought of in much more detail...

Have you seen debconf? It is a vaguely similar system, designed to ask
questions through a variety of interfaces, to configure some of the programs
installed on a machine. I don't know how it works, but it sounds somewhat
similar to this...

&gt; 
&gt; Another key feature is the fact that the config files can be 
&gt; parsed by a 
&gt; library, and so that is less effort for app developers. Not 
&gt; only do I want 
&gt; the library to parse files, but I want it to take care of 
&gt; opening them. That 
&gt; way, say "samba" doesn't care where the config file is, it 
&gt; asks the library 
&gt; to find and open it - hence the /etc directory can be 
&gt; organised anyway the 
&gt; distributor sees fit, it wont break applications (and wont 
&gt; require 1000 
&gt; symlinks everywhere). I imagine config file lookup would be 
&gt; similar to how 
&gt; libraries are looked up by the linker (i.e. probably maintain 
&gt; a cache, and 
&gt; have a search-path setup. The app using the library could 
&gt; also give libetc 
&gt; hints, such as saying that it is a "service", and so libetc 
&gt; searches the 
&gt; "service" directory first).

Interesting concept.

&gt; 
&gt; *phew*, okay I'm going to go think about what this syntax 
&gt; should look like, 
&gt; starting with the XML produced by QTDesigner. Thanks for the feedback!

Good luck :)

&gt; 
&gt; Cheers,
&gt; 
&gt; Damien
&gt; 
&gt; P.S.: The /dev/pts/gui thing is meant for desktop/home user 
&gt; systems, stop 
&gt; thinking like a sysadmin! :) At home, users are their own 

I AM a sysadmin! :)

&gt; admins and need 
&gt; hand holding occasionally (and typing "tail -100 
&gt; /var/log/messages | less" is 
&gt; too much for them).

true. I am definitely coming at this from a sysadmin's perspective, because
that's what I do. I have also had large-scale and detailed dreams of a new
config system that I once tried to implement (with some friends). The idea
behind my system was to have many remote machines with similar
configurations (eg for small businesses) all configured and maintained
centrally...

&gt; 
&gt; APPENDIX: 
&gt; 
&gt; As for your comment saying that people would say the current 
&gt; system isn't that 
&gt; complex, I'm going by what my /etc directory looks like. Here 
&gt; I see that 
&gt; postfix has it's own directory, but proftpd doesnt, samba has 
&gt; it's own 
&gt; directory, but tmdns doesnt, etc... In the /etc root 
&gt; directory we see config 
&gt; files for things from printers to timezone to mail to boot 
&gt; configuration. 
&gt; None of this directory has any sort of organisation except 
&gt; for the rc.d 
&gt; init.d stuff...

It's complex for a newbie or a home user, but once you get used to it, it's
not that bad. I certainly would object to having to type
/etc/services/samba/smb.conf every time I needed to change it. It's not
neccessarily the typing, but needing to remember how each program is
classified. 

&gt; 
&gt; I believe it is broken.

It's broken, but it's still very usable, and if a better idea was invented,
gaining traction would be very very hard.

My personal suggestion:

invent /newetc (or /ucf or something)

/newetc would look like this:

/newetc/
 services/
  smb/
  ftp/
  http/
  ...
 network/
  ppp/
  ip/
  ...

 -- ie however you want it.

Inside these directories would be config files, all in a single format
(*.ucf), with user configuration in them.

There would also be another directory, called /newetc/defaults/ or something
similar (perhaps not even within /newetc) ... It would have an identical
directory structure, with an equivalent .ucf file for each config file
containing default values, and a UI description file. These would not be
editable by the user (or at least, shouldn't be edited). 

Whatever format you want to use (I'll choose XML here), the idea would be
that the config files would override the defaults. IE if you copied the
default file verbatim, you would get a perfectly valid config file, with
default settings. Likewise, if you removed the config file entirely, or had
an empty one, the system would just use the defaults.

There would then be a tool that would take the /newetc files and generate
the /etc files from them. This tool would have to know all about the formats
of the real files, and how to generate these formats, but wouldn't need to
generate human-readable files, because you're replacing /etc with /newetc,
right?

So, taking an eg, a real debian network config file looks like this (in
part):

----
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
        address 202.6.145.73
        netmask 255.255.255.248
        network 202.6.145.72
        broadcast 202.6.145.79
        gateway 202.6.145.78
----

We could turn this into UCF format (which is actually Richard's Quasi-XML)
something like this:

----
&lt;interface&gt;
  &lt;name&gt;lo&lt;/name&gt;
  &lt;auto&gt;true&lt;/auto&gt;
  &lt;family&gt;inet&lt;/family&gt;
  &lt;method&gt;loopback&lt;/method&gt;
&lt;/interface&gt;

&lt;interface&gt;
  &lt;name&gt;eth0&lt;/name&gt;
  &lt;auto&gt;true&lt;/auto&gt;
  &lt;family&gt;inet&lt;/family&gt;
  &lt;method&gt;static&lt;/method&gt;
  &lt;options&gt;
    &lt;address&gt;202.6.145.73&lt;/address&gt;
    &lt;netmask&gt;255.255.255.248&lt;/netmask&gt;
    &lt;network&gt;202.6.145.72&lt;/network&gt;
    &lt;broadcast&gt;202.6.145.79&lt;/broadcast&gt;
    &lt;gateway&gt;202.6.145.78&lt;/gateway&gt;
  &lt;/options&gt;
&lt;/interface&gt;
----

The defaults file could be something like this:

----
&lt;interface&gt;
  &lt;name&gt;lo&lt;/name&gt;
  &lt;auto&gt;true&lt;/auto&gt;
  &lt;family&gt;inet&lt;/family&gt;
  &lt;method&gt;loopback&lt;/method&gt;
&lt;/interface&gt;

&lt;interface&gt;
  &lt;name&gt;eth0&lt;/name&gt;
  &lt;auto&gt;true&lt;/auto&gt;
  &lt;family&gt;inet&lt;/family&gt;
  &lt;method&gt;dhcp&lt;/method&gt;
&lt;/interface&gt;
----

... which would, of course, mean that the loopback section in the config
file is redundant... (and please ignore the sensibility or otherwise of my
choice of defaults)

And the ui description file could be something like:

----
er... no idea, but I'm thinking of something vaguely DTD-like, which can
specify data type, a UI name for the data, and some help text...
----

The config-generator would generate the real network/interfaces file from
this, and hey, you have a configured system. If you wanted to port this to
another distro, you would change the config-generator, and maintain the
files the same... Of course, the config-generator itself could be made
modular, so you might have a generator for sendmail, a subclass of that for
RedHat-standard sendmail, one for debian-standard sendmail, another for
courier, another for apache, and so on. The specific generator for each
component could be set in the defaults file for the config-generator, and
then overridden by the user in a config file, as above. This way, a distro
could use it to have everything a certain way, and then the user could say
install postfix rather than sendmail, and change the
&lt;mailconfig&gt;redhat-sendmail&lt;/mailconfig&gt; line to
&lt;mailconfig&gt;standard-postfix&lt;/mailconfig&gt; or something similar (perhaps just
add that line to the config file, and it would override the default. If they
wanted qmail, and no config-generator was available, they could have
&lt;mailconfig&gt;null&lt;/mailconfig&gt; or something, and no config would be
generated, so the standard etc files would be used.

This rough-edged concept meets all your original criteria, plus a few
more...

- sane filetree
- standardised config file syntax (which may or may not be XML-ish) which
is:
  - human read/writable
  - machine parseable
  - capable of defining a UI (without interfering with config file itself)
- library could parse this tree -- probably made easier if XML is chosen.
- distro-independant (as long as the config-generator is maintained for
chosen distro)
- doesn't require rewriting existing programs, though allows it
- would still allow using of standard config files to ease migration

Of course, there are disadvantages. I see three main ones:

* you'd have to maintain a config-generator for every program you want to
configure, which itself would need to be adaptable to different versions and
distributions of each program. This would be a lot of work, though less than
modifying each program. 
* no-one knows it. People know the present /etc system well.
* it may not be capable of handling some of the more complex config files,
particularly those which are actually shell (or other) scripts, and require
executing rather than just reading.

Anyway, that's enough daydreaming for now.

rr

-- 
Richard Russell
Yellow Goanna P/L
m: +61 412 827 805
e: <A HREF="mailto:richard@yellowgoanna.com">richard@yellowgoanna.com</A>
w: <A HREF="http://www.yellowgoanna.com">http://www.yellowgoanna.com</A>

-- 
LinuxSA WWW: <A HREF="http://www.linuxsa.org.au/">http://www.linuxsa.org.au/</A> IRC: #linuxsa on irc.freenode.net
To unsubscribe from the LinuxSA list:
  mail <A HREF="mailto:linuxsa-request@linuxsa.org.au">linuxsa-request@linuxsa.org.au</A> with "unsubscribe" as the subject

</PRE>
<!-- Body="End" -->
<!-- IndexControl2="Start" -->
<HR>
Index:
[<A HREF="thread.html">thread</A>]
[<A HREF="date.html">date</A>]
[<A HREF="subject.html">subject</A>]
[<A HREF="author.html">author</A>]
[<A HREF="stats.html">stats</A>]
<!-- IndexControl2="End" -->
<HR><FONT SIZE=+1>Return to the <A HREF=/mailing-list/>LinuxSA Mailing List Information</A> Page</FONT></BODY>
</HTML>
